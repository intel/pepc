# -*- coding: utf-8 -*-
# vim: ts=4 sw=4 tw=100 et ai si
#
# Copyright (C) 2020-2022 Intel Corporation
# SPDX-License-Identifier: BSD-3-Clause
#
# Authors: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
#          Antti Laakso <antti.laakso@linux.intel.com>
#          Niklas Neronin <niklas.neronin@intel.com>

"""
This module implements CPU properties caching.
"""

from pepclibs import CPUInfo
from pepclibs.helperlibs import ClassHelpers
from pepclibs.helperlibs.Exceptions import Error, ErrorNotFound

class PropsCache():
    """
    This class implements properties caching. The cache is indexed by property name and CPU number.
    It takes the CPU scope (global 0, package 3, etc) into account as well. The cache uses the
    write-through policy.
    """

    def is_cached(self, pname, cpu, method=None):
        """
        Check if '(pname, cpu, method)' exists in the cache. Return 'True' if the item was found and
        'False' otherwise. The argument are as follows.
          * pname - name of the property.
          * cpu - an integer CPU number.
          * method - optional method name for the property.

        About the 'method' argument. A property may be obtained or modified using different methods,
        for example via an MSR register of via a sysfs file. The 'method' argument can be used for
        distinguishing between different methods. If 'method' is used for at least one cached
        property, it has to be used for all the other cached proerties.
        """

        if not self._enable_cache:
            return False

        if method in self._cache and pname in self._cache[method] and \
           cpu in self._cache[method][pname]:
            return True
        return False

    def get(self, pname, cpu, method=None):
        """
        Look up the '(pname, cpu)' in the cache. Return the value if the item was found, raise
        'ErrorNotFound' otherwise. The argument are as follows.
          * pname - name of the property.
          * cpu - an integer CPU number.
          * method - optional method name for the property (see a note in 'is_cached()' docstring).
        """

        try:
            return self._cache[method][pname][cpu]
        except KeyError:
            raise ErrorNotFound(f"{pname} is not cached for CPU {cpu}") from None

    def remove(self, pname, cpu, sname="CPU", method=None):
        """
        Remove '(pname, cpu)' and all the other items sharing the same scope from the cache.
          * pname - name of the property.
          * cpu - an integer CPU number.
          * sname - name of scope (e.g. "package", "core").
          * method - optional method name for the property (see a note in 'is_cached()' docstring).
        """

        if not self._enable_cache:
            return

        if sname == "global":
            del self._cache[method][pname]
            return

        cpus = self._cpuinfo.get_cpu_siblings(cpu, sname)

        for cpu in cpus: # pylint: disable=redefined-argument-from-local
            try:
                del self._cache[method][pname][cpu]
            except KeyError:
                pass

    def add(self, pname, cpu, val, sname="CPU", method=None):
        """
        Add value 'val' for item '(pname, cpu)' to the cache. Add it also for each CPU sharing the
        same scope. The argument are as follows.
          * pname - name of the property.
          * cpu - an integer CPU number.
          * val - value to get cached.
          * sname - name of scope (e.g. "package", "core").
          * method - optional method name for the property (see a note in 'is_cached()' docstring).

        Return 'val'.
        """

        if not self._enable_cache:
            return val

        if method is not None:
            self._method_used = True

        if method is None and self._method_used:
            raise Error("BUG: provide 'method' argument for all properties")

        cpus = self._cpuinfo.get_cpu_siblings(cpu, sname)

        if method not in self._cache:
            self._cache[method] = {}
        if pname not in self._cache[method]:
            self._cache[method][pname] = {}
        for cpu in cpus: # pylint: disable=redefined-argument-from-local
            self._cache[method][pname][cpu] = val

        return val

    def __init__(self, cpuinfo=None, pman=None, enable_cache=True):
        """
        The class constructor. The argument are as follows.
          * pman - the process manager object that defines the host to run the measurements on.
          * cpuinfo - CPU information object generated by 'CPUInfo.CPUInfo()'.
          * enable_cache - this argument can be used to disable caching.
        """

        self._enable_cache = enable_cache
        if not self._enable_cache:
            return

        self._cpuinfo = cpuinfo
        self._close_cpuinfo = cpuinfo is None

        # 'True' if 'method' was provided for at least one property.
        self._method_used = False

        if not self._cpuinfo:
            # 'pman' is only used to initialize 'cpuinfo' in this class.
            self._cpuinfo = CPUInfo.CPUInfo(pman=pman)

        self._cache = {}

    def close(self):
        """Uninitialize the class object."""

        ClassHelpers.close(self, close_attrs=("_cpuinfo",))
