# -*- coding: utf-8 -*-
# vim: ts=4 sw=4 tw=100 et ai si
#
# Copyright (C) 2020-2022 Intel Corporation
# SPDX-License-Identifier: BSD-3-Clause
#
# Authors: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
#          Antti Laakso <antti.laakso@linux.intel.com>
#          Niklas Neronin <niklas.neronin@intel.com>

"""
This module implements CPU properties caching.
"""

from pepclibs import CPUInfo
from pepclibs.helperlibs import ClassHelpers
from pepclibs.helperlibs.Exceptions import Error, ErrorNotFound

class PropsCache():
    """
    This class implements properties caching. The cache is indexed by property name and CPU number.
    It takes the CPU scope (global 0, package 3, etc) into account as well. The cache uses the
    write-through policy.
    """

    def is_cached(self, pname, cpu, mname=None):
        """
        Check if '(pname, cpu, mname)' exists in the cache. Return 'True' if the item was found and
        'False' otherwise. Arguments are the same as in 'get()'.
        """

        try:
            self.get(pname, cpu, mname=mname)
        except Error:
            return False
        return True

    def get(self, pname, cpu, mname=None):
        """
        Look up the '(pname, cpu, mname)' in the cache. Return the value if the item was found,
        raise 'ErrorNotFound' otherwise. The argument are as follows.
          * pname - name of the property.
          * cpu - an integer CPU number.
          * mname - optional mechanism name for the property.

        About the 'mname' argument. A property may be obtained or modified using different
        mechanisms, for example via an MSR register of via a sysfs file. The 'mname' argument can be
        used for distinguishing between different mechanisms. If 'mname' is used for at least one
        cached property, it has to be used for all the other cached proerties.
        """

        if not self._enable_cache:
            raise ErrorNotFound("caching is disabled")

        try:
            return self._cache[mname][pname][cpu]
        except KeyError:
            raise ErrorNotFound(f"{pname} is not cached for CPU {cpu}") from None

    def remove(self, pname, cpu, sname="CPU", mname=None):
        """
        Remove '(pname, cpu)' and all the other items sharing the same scope from the cache.
          * pname - name of the property.
          * cpu - an integer CPU number.
          * sname - name of scope (e.g. "package", "core").
          * mname - optional mechanism name for the property (see a note in 'get()' docstring).
        """

        if not self._enable_cache:
            return

        if sname == "global":
            del self._cache[mname][pname]
            return

        cpus = self._cpuinfo.get_cpu_siblings(cpu, sname)

        for cpu in cpus: # pylint: disable=redefined-argument-from-local
            try:
                del self._cache[mname][pname][cpu]
            except KeyError:
                pass

    def add(self, pname, cpu, val, sname="CPU", mname=None):
        """
        Add value 'val' for item '(pname, cpu)' to the cache. Add it also for each CPU sharing the
        same scope. The argument are as follows.
          * pname - name of the property.
          * cpu - an integer CPU number.
          * val - value to get cached.
          * sname - name of scope (e.g. "package", "core").
          * mname - optional mechanism name for the property (see a note in 'get()' docstring).

        Return 'val'.
        """

        if not self._enable_cache:
            return val

        if mname is not None:
            self._mechanism_used = True

        if mname is None and self._mechanism_used:
            raise Error("BUG: provide 'mname' argument for all properties")

        cpus = self._cpuinfo.get_cpu_siblings(cpu, sname)

        if mname not in self._cache:
            self._cache[mname] = {}
        if pname not in self._cache[mname]:
            self._cache[mname][pname] = {}
        for cpu in cpus: # pylint: disable=redefined-argument-from-local
            self._cache[mname][pname][cpu] = val

        return val

    def __init__(self, cpuinfo=None, pman=None, enable_cache=True):
        """
        The class constructor. The argument are as follows.
          * pman - the process manager object that defines the host to run the measurements on.
          * cpuinfo - CPU information object generated by 'CPUInfo.CPUInfo()'.
          * enable_cache - this argument can be used to disable caching.
        """

        self._enable_cache = enable_cache
        if not self._enable_cache:
            return

        self._cpuinfo = cpuinfo
        self._close_cpuinfo = cpuinfo is None

        # 'True' if 'mname' was provided for at least one property.
        self._mechanism_used = False

        if not self._cpuinfo:
            # 'pman' is only used to initialize 'cpuinfo' in this class.
            self._cpuinfo = CPUInfo.CPUInfo(pman=pman)

        self._cache = {}

    def close(self):
        """Uninitialize the class object."""

        ClassHelpers.close(self, close_attrs=("_cpuinfo",))
