# -*- coding: utf-8 -*-
# vim: ts=4 sw=4 tw=100 et ai si
#
# Copyright (C) 2020-2021 Intel Corporation
# SPDX-License-Identifier: BSD-3-Clause
#
# Authors: Antti Laakso <antti.laakso@linux.intel.com>
#          Artem Bityutskiy <artem.bityutskiy@linux.intel.com>

"""
This module provides API to MSR 0x1FC (MSR_POWER_CTL). This is a model-specific register found on
many Intel platforms.
"""

from pepclibs import CPUInfo
from pepclibs.msr import _FeaturedMSR

# The Power Control Model Specific Register.
MSR_POWER_CTL = 0x1FC

# CPU models supporting the C-state pre-wake feature.
_CSTATE_PREWAKE_CPUS = (CPUInfo.CPUS["GRANITERAPIDS_X"]["model"],
                        CPUInfo.CPUS["GRANITERAPIDS_D"]["model"],
                        CPUInfo.CPUS["EMERALDRAPIDS_X"]["model"],
                        CPUInfo.CPUS["SAPPHIRERAPIDS_X"]["model"],
                        CPUInfo.CPUS["ICELAKE_X"]["model"],
                        CPUInfo.CPUS["ICELAKE_D"]["model"],
                        CPUInfo.CPUS["SKYLAKE_X"]["model"],
                        CPUInfo.CPUS["BROADWELL_X"]["model"],
                        CPUInfo.CPUS["HASWELL_X"]["model"],
                        CPUInfo.CPUS["IVYBRIDGE_X"]["model"],)

# CPU models supporting the LTR feature.
LTR_CPUS = (CPUInfo.CPUS["GRANITERAPIDS_X"]["model"],
            CPUInfo.CPUS["EMERALDRAPIDS_X"]["model"],
            CPUInfo.CPUS["SAPPHIRERAPIDS_X"]["model"],
            CPUInfo.CPUS["ICELAKE_X"]["model"],)

# CPU models supporting the PCH negotiation feature.
_PCH_NEGOTIATION_CPUS = (CPUInfo.CPUS["EMERALDRAPIDS_X"]["model"],)

# Description of CPU features controlled by the Power Control MSR. Please, refer to the notes
# for '_FeaturedMSR.FEATURES' for more comments.
#
# Note: while the "C-state prewake" feature available on many CPUs, in practice it works only on
#       some platforms, like Ice Lake Xeon. Therefore we mark it as "supported" only for those
#       platforms where we know it works.
FEATURES = {
    "c1e_autopromote" : {
        "name" : "C1E autopromote",
        "sname": None,
        "help" : "When enabled, the CPU automatically converts all C1 requests to C1E requests.",
        "type" : "bool",
        "vals" : {"on" : 1, "off" : 0},
        "bits" : (1, 1),
    },
    "cstate_prewake" : {
        "name" : "C-state prewake",
        "sname": None,
        "help" : """When enabled, the CPU will start exiting the C6 idle state in advance, prior to
                    the next local APIC timer event.""",
        "cpumodels" : _CSTATE_PREWAKE_CPUS,
        "type" : "bool",
        "vals" : {"on" : 0, "off" : 1},
        "bits" : (30, 30),
    },
    "ltr" : {
        "name" : "LTR (Latency Tolerance Reporting)",
        "sname": "package",
        "help" : """When enabled, the CPU will take LTR constraints into account when making power
                    management decisions, such as selecting package C-state.""",
        "cpumodels" : LTR_CPUS,
        "type" : "bool",
        "vals" : { "on" : 0, "off" : 1},
        "bits" : (35, 35),
    },
    "pch_negotiation" : {
        "name" : "PCH negotiation",
        "sname": None,
        "help" : """When enabled, processor's PCU (Power Control Unit) informs PCH (Platform
                    Controller Hub) about entering and exiting package C6 state (PC6). Depending on
                    configuration, PCH may use this information to minimize its interactions with
                    the processor. This may improve PC6 residency and drives idle power down.""",
        "cpumodels" : _PCH_NEGOTIATION_CPUS,
        "type" : "bool",
        "vals" : {"on" : 0, "off" : 1},
        "bits" : (36, 36),
    },
}

class PowerCtl(_FeaturedMSR.FeaturedMSR):
    """
    This class provides API to MSR 0x1FC (MSR_POWER_CTL). This is a model-specific register found on
    many Intel platforms.
    """

    regaddr = MSR_POWER_CTL
    regname = "MSR_POWER_CTL"
    vendor = "GenuineIntel"

    def _set_baseclass_attributes(self):
        """Set the attributes the superclass requires."""

        self.features = FEATURES

        # MSR_POWER_CTL features have package scope, except for Cascade Lake AP, which has two dies,
        # and the features have die scope.
        model = self._cpuinfo.info["model"]
        if model == CPUInfo.CPUS["SKYLAKE_X"]["model"] and \
           len(self._cpuinfo.get_dies(package=0)) > 1:
            sname = "die"
        else:
            sname = "package"

        for finfo in self.features.values():
            finfo["sname"] = sname

    def __init__(self, pman=None, cpuinfo=None, msr=None):
        """
        The class constructor. The argument are as follows.
          * pman - the process manager object that defines the host to run the measurements on.
          * cpuinfo - CPU information object generated by 'CPUInfo.CPUInfo()'.
          * msr - the 'MSR.MSR()' object to use for writing to the MSR register.
        """

        super().__init__(pman=pman, cpuinfo=cpuinfo, msr=msr)
