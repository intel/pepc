# -*- coding: utf-8 -*-
# vim: ts=4 sw=4 tw=100 et ai si
#
# Copyright (C) 2023 Intel Corporation
# SPDX-License-Identifier: BSD-3-Clause
#
# Authors: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
#          Antti Laakso <antti.laakso@linux.intel.com>
#          Niklas Neronin <niklas.neronin@intel.com>

"""
This module provides a capability of reading and changing CPU frequency.
"""

import time
import logging
import contextlib
from pathlib import Path
from pepclibs import CPUInfo, _PerCPUCache, _SysfsIO
from pepclibs.helperlibs import LocalProcessManager, ClassHelpers, Trivial
from pepclibs.helperlibs.Exceptions import Error, ErrorNotFound, ErrorNotSupported
from pepclibs.helperlibs.Exceptions import ErrorVerifyFailed

_LOG = logging.getLogger()

class _CPUFreqSysfsBase(ClassHelpers.SimpleCloseContext):
    """
    Base class for 'CPUFreqSysfs' and 'CPUFreqCPPC'. Includes common functionality.
    """

    def __init__(self, pman=None, cpuinfo=None, enable_cache=True):
        """
        The class constructor. The argument are as follows.
          * pman - the process manager object that defines the host to get/set CPU frequency on.
          * cpuinfo - CPU information object generated by 'CPUInfo.CPUInfo()'.
          * enable_cache - this argument can be used to disable caching.
        """

        self._pman = pman
        self._cpuinfo = cpuinfo
        self._enable_cache = enable_cache

        self._close_pman = pman is None
        self._close_cpuinfo = cpuinfo is None

        self._sysfs_io = None
        self._sysfs_base = Path("/sys/devices/system/cpu")

        if not self._pman:
            self._pman = LocalProcessManager.LocalProcessManager()

        if not self._cpuinfo:
            self._cpuinfo = CPUInfo.CPUInfo(pman=self._pman)

        self._sysfs_io = _SysfsIO.SysfsIO(pman=pman)

        self._cache = _PerCPUCache.PerCPUCache(cpuinfo=self._cpuinfo, pman=self._pman,
                                               enable_cache=enable_cache)

    def close(self):
        """Uninitialize the class object."""

        close_attrs = ("_cache", "_sysfs_io", "_cpuinfo", "_pman")
        ClassHelpers.close(self, close_attrs=close_attrs)

class CPUFreqSysfs(_CPUFreqSysfsBase):
    """
    This class provides a capability of reading and changing CPU frequency via Linux "cpufreq"
    subsystem sysfs interfaces.

    Public methods overview.

    1. Get/set CPU frequency via Linux "cpufreq" sysfs interfaces:
       * 'get_min_freq()'
       * 'get_max_freq()'
       * 'set_min_freq()'
       * 'set_max_freq()'
    2. Get CPU frequency limits via Linux "cpufreq" sysfs interfaces:
       * 'get_min_freq_limit()'
       * 'get_max_freq_limit()'
    3. Get avalilable CPU frequencies list:
       * 'get_available_frequencies()'
    4. Get CPU base frequency:
       * 'get_base_freq()'

    Note, class methods do not validate the CPU number argument. The caller is assumed to have done
    the validation. The input CPU number should exist and should be online.
    """

    def _get_policy_sysfs_path(self, cpu, fname):
        """Construct and return a Linux "cpufreq" policy sysfs path for file 'fname'."""

        return self._sysfs_base / "cpufreq" / f"policy{cpu}" / fname

    def _get_cpu_freq_sysfs_path(self, key, cpu, limit=False):
        """Get the sysfs file path for a CPU frequency read of write operation."""

        fname = "scaling_" + key + "_freq"
        prefix = "cpuinfo_" if limit else "scaling_"
        fname = prefix + key + "_freq"
        return self._get_policy_sysfs_path(cpu, fname)

    def _get_freq_sysfs(self, key, cpu, limit=False):
        """Get CPU frequency from the Linux "cpufreq" sysfs file."""

        path = self._get_cpu_freq_sysfs_path(key, cpu, limit=limit)

        with contextlib.suppress(ErrorNotFound):
            return self._cache.get(path, cpu)

        _LOG.debug("reading %s CPU frequency for CPU%d from '%s'%s",
                   key, cpu, path, self._pman.hostmsg)

        freq = self._sysfs_io.read_int(path, what=f"{key}. frequency for CPU {cpu}")
        if freq is None:
            return None

        # The frequency value is in kHz in sysfs.
        freq *= 1000
        return self._cache.add(path, cpu, freq, sname="CPU")

    def get_min_freq(self, cpu):
        """
        Get minimum CPU frequency via Linux "cpufreq" sysfs interfaces. The arguments are as
        follows.
          * cpu - CPU number to get the frequency for.

        Return the minimum CPU frequency in Hz or 'None' if the CPU frequency sysfs file does not
        exist.
        """

        return self._get_freq_sysfs("min", cpu)

    def get_max_freq(self, cpu):
        """Same as 'get_min_freq()', but for the maximum CPU frequency."""

        return self._get_freq_sysfs("max", cpu)

    def get_min_freq_limit(self, cpu):
        """
        Get minimum CPU frequency limit via Linux "cpufreq" sysfs interfaces. The arguments are as
        follows.
          * cpu - CPU number to get the frequency for.

        Return the minimum CPU frequency limit in Hz or 'None' if the CPU frequency sysfs file does
        not exist.
        """

        return self._get_freq_sysfs("min", cpu, limit=True)

    def get_max_freq_limit(self, cpu):
        """Same as 'get_min_freq_sysfs()', but for the maximum CPU frequency."""

        return self._get_freq_sysfs("max", cpu, limit=True)

    def _set_freq_sysfs(self, freq, key, cpu):
        """Set CPU frequency by writing to the Linux "cpufreq" sysfs file."""

        path = self._get_cpu_freq_sysfs_path(key, cpu)

        _LOG.debug("writing %s CPU frequency value '%d' for CPU%d to '%s'%s",
                   key, freq // 1000, cpu, path, self._pman.hostmsg)

        self._cache.remove(path, cpu, sname="CPU")

        self._sysfs_io.write(path, str(freq // 1000), what=f"{key}. CPU frequency")

        count = 3
        while count > 0:
            # Read CPU frequency back and verify that it was set correctly.
            new_freq = self._sysfs_io.read_int(path, what=f"{key}. CPU frequency")
            new_freq *= 1000
            if freq == new_freq:
                return self._cache.add(path, cpu, freq, sname="CPU")

            # Sometimes the update does not happen immediately. For example, we observed this on
            # Intel systems with HWP enabled. Wait a little bit and try again.
            time.sleep(0.1)
            count -= 1

        raise ErrorVerifyFailed(f"failed to set {key}. CPU frequency to {freq} for CPU{cpu}"
                                f"{self._pman.hostmsg}: wrote '{freq // 1000}' to '{path}', but "
                                f"read '{new_freq // 1000}' back",
                                cpu=cpu, expected=freq, actual=new_freq, path=path)

    def set_min_freq(self, freq, cpu):
        """
        Set minimum CPU frequency via Linux "cpufreq" sysfs interfaces. The arguments are as
        follows.
          * freq - the minimum frequency value to set, hertz.
          * cpu - CPU number to set the frequency for.
        """

        self._set_freq_sysfs(freq, "min", cpu)

    def set_max_freq(self, freq, cpu):
        """Same as 'set_min_freq()', but for the maximum CPU frequency."""

        self._set_freq_sysfs(freq, "max", cpu)

    def get_available_frequencies(self, cpu):
        """
        Get the list of available CPU frequency values. The arguments are as follows.
          * cpu - CPU number to get the list of available frequencies for.

        Return the list of available frequencies Hz or 'None' if the frequencies sysfs file does not
        exist. The sysfs file provided by the 'acpi-cpufreq' driver. but 'intel_idle' driver does
        not provide it.
        """

        path = self._get_policy_sysfs_path(cpu, "scaling_available_frequencies")

        with contextlib.suppress(ErrorNotFound):
            return self._cache.get(path, cpu)

        val = self._sysfs_io.read(path, what="available CPU frequencies")
        if val is None:
            return self._cache.add(path, cpu, None, sname="CPU")

        freqs = []
        for freq in val.split():
            try:
                freq = Trivial.str_to_int(freq, what="CPU frequency value")
                freqs.append(freq * 1000)
            except Error as err:
                raise Error(f"bad contents of file '{path}'{self._pman.hostmsg}\n{err.indent(2)}") \
                            from err

        freqs = sorted(freqs)
        return self._cache.add(path, cpu, freqs, sname="CPU")

    def _get_base_freq_intel_pstate(self, cpu):
        """Get CPU base frequency from 'intel_pstate' driver's sysfs file."""

        path = self._get_policy_sysfs_path(cpu, "base_frequency")

        with contextlib.suppress(ErrorNotFound):
            return self._cache.get(path, cpu)

        freq = self._sysfs_io.read_int(path, what=f"base frequency for CPU {cpu}")
        if freq is None:
            return None

        # The frequency value is in kHz in sysfs.
        freq *= 1000
        return self._cache.add(path, cpu, freq, sname="CPU")

    def _get_base_freq_bios_limit(self, cpu):
        """Get CPU base frequency from the 'bios_limit' sysfs file."""

        path = self._sysfs_base / f"cpu{cpu}/cpufreq/bios_limit"

        with contextlib.suppress(ErrorNotFound):
            return self._cache.get(path, cpu)

        freq = self._sysfs_io.read_int(path, what=f"base frequency for CPU {cpu}")
        if freq is None:
            return None

        # The frequency value is in kHz in sysfs.
        freq *= 1000
        return self._cache.add(path, cpu, freq, sname="CPU")

    def get_base_freq(self, cpu):
        """
        Get CPU base frequency via Linux "cpufreq" sysfs interfaces. The arguments are as follows.
          * cpu - CPU number to get base frequency for.

        Return the base frequency vaule in Hz or 'None' if the bae frequency sysfs files do not
        exist.
        """

        freq = self._get_base_freq_intel_pstate(cpu)
        if freq is None:
            freq = self._get_base_freq_bios_limit(cpu)
        return freq

class CPUFreqCPPC(_CPUFreqSysfsBase):
    """
    This class provides a cpability of reading CPU frequency information from ACPI CPPC via Linux
    sysfs interfaces.

    Public methods overview.

    1. Get CPU frequency limits from ACPI CPPC.
       * 'get_min_freq_limit()'
       * 'get_max_freq_limit()'
    1. Get CPU performance limits from ACPI CPPC.
       * 'get_min_perf_limit()'
       * 'get_max_perf_limit()'
    4. Get CPU base frequency and performance from ACPI CPPC:
       * 'get_base_freq()'
       * 'get_base_perf()'
    """

    def _get_sysfs_path(self, cpu, fname):
        """Construct and return CPPC sysfs file path."""

        return self._sysfs_base / f"cpu{cpu}/acpi_cppc" / fname

    def _read_cppc_sysfs_file(self, cpu, fname, what):
        """Read ACPI CPPC sysfs file 'fname' for CPU 'cpu'."""

        path = self._get_sysfs_path(cpu, fname)

        with contextlib.suppress(ErrorNotFound):
            return self._cache.get(path, cpu)

        val = None

        try:
            val = self._sysfs_io.read_int(path, what=what)
        except Error as err:
            # On some platforms reading CPPC sysfs files always fails. So treat these errors as if
            # the sysfs file was not even available and return 'None'.
            _LOG.debug(err)
            _LOG.warn_once("ACPI CPPC sysfs file '%s' is not readable%s", path, self._pman.hostmsg)

        return self._cache.add(path, cpu, val, sname="CPU")

    def get_min_freq_limit(self, cpu):
        """
        Get minimum CPU frequency limit from ACPI CPPC via Linux sysfs interfaces. The arguments are
        as follows.
          * cpu - CPU number to get the frequency limit for.

        Return the minimum CPU frequency limit in Hz or 'None' if the CPU frequency sysfs file does
        not exist.
        """

        val = self._read_cppc_sysfs_file(cpu, "lowest_freq", f"min. CPU {cpu} frequency limit")
        if val:
            # CPPC sysfs files use MHz.
            val *= 1000 * 1000
        return val

    def get_max_freq_limit(self, cpu):
        """Same as 'get_min_freq_limit()', but for the maximum CPU frequency limit."""

        val = self._read_cppc_sysfs_file(cpu, "highest_freq", f"max. CPU {cpu} frequency limit")
        if val:
            # CPPC sysfs files use MHz.
            val *= 1000 * 1000
        return val

    def get_min_perf_limit(self, cpu):
        """
        Get minimum CPU performance limit from ACPI CPPC via Linux sysfs interfaces. The arguments
        are as follows.
          * cpu - CPU number to get the frequency limit for.

        Return the minimum CPU limit or 'None' if the CPU frequency sysfs file does not exist.
        """

        return self._read_cppc_sysfs_file(cpu, "lowest_perf", f"min. CPU {cpu} performance limit")

    def get_max_perf_limit(self, cpu):
        """Same as 'get_min_perf_limit()', but for the maximum CPU performance limit."""

        return self._read_cppc_sysfs_file(cpu, "highest_perf", f"max. CPU {cpu} performance limit")

    def get_base_freq(self, cpu):
        """
        Get base CPU frequency from ACPI CPPC via Linux sysfs interfaces. The arguments are as
        follows.
          * cpu - CPU number to get the base frequency for.

        Return the base CPU frequency in Hz or 'None' if the CPU frequency sysfs file does not
        exist.
        """

        val = self._read_cppc_sysfs_file(cpu, "nominal_freq", f"base CPU {cpu} frequency")
        if val:
            # CPPC sysfs files use MHz.
            val *= 1000 * 1000
        return val

    def get_base_perf(self, cpu):
        """
        Get base CPU performance from ACPI CPPC via Linux sysfs interfaces. The arguments are as
        follows.
          * cpu - CPU number to get the base performance for.

        Return the base CPU performance in Hz or 'None' if the CPU performance sysfs file does not
        exist.
        """

        return self._read_cppc_sysfs_file(cpu, "nominal_perf", f"base CPU {cpu} performance")

class CPUFreqMSR(ClassHelpers.SimpleCloseContext):
    """
    This class provides a capability of reading and changing CPU frequency for Intel platforms
    supporting thie 'MSR_HWP_REQUEST' model-specific register (MSR).

    Public methods overview.

    1. Get/set CPU frequency via an MSR (Intel CPUs only):
       * 'get_min_freq()'
       * 'get_max_freq()'
       * 'set_min_freq()'
       * 'set_max_freq()'
    3. Get base frequency via an MSR (Intel CPUs only):
       * 'get_base_freq()'
    4. Get the minimum CPU operating frequency via an MSR (Intel CPUs only):
       * 'get_min_oper_freq()'
    5. Get the maximum CPU efficiency frequency via an MSR (Intel CPUs only):
       * 'get_max_eff_freq()'
    6. Get the maximum CPU turbo frequency via an MSR (Intel CPUs only):
       * 'get_max_turbo_freq()'

    Note, class methods do not validate the CPU number argument. The caller is assumed to have done
    the validation. The input CPU number should exist and should be online.
    """

    def _get_msr(self):
        """Returns an 'MSR.MSR()' object."""

        if not self._msr:
            from pepclibs.msr import MSR # pylint: disable=import-outside-toplevel

            self._msr = MSR.MSR(self._pman, cpuinfo=self._cpuinfo, enable_cache=self._enable_cache)

        return self._msr

    def _get_fsbfreq(self):
        """Discover bus clock speed."""

        if not self._fsbfreq:
            from pepclibs.msr import FSBFreq # pylint: disable=import-outside-toplevel

            msr = self._get_msr()
            self._fsbfreq = FSBFreq.FSBFreq(pman=self._pman, cpuinfo=self._cpuinfo, msr=msr)

        return self._fsbfreq

    def _get_bclk(self, cpu, not_supported_ok=True):
        """
        Return bus clock speed in Hz. Return 'None' if bus clock is not supported by the platform.
        """

        try:
            bclk = self._get_fsbfreq().read_cpu_feature("fsb", cpu)
        except ErrorNotSupported:
            # Fall back to 100MHz clock speed.
            if self._cpuinfo.info["vendor"] == "GenuineIntel":
                return 100000000
            if not_supported_ok:
                return None
            raise

        # Convert MHz to Hz.
        return int(bclk * 1000000)

    def _get_hwpreq(self):
        """Returns an 'HWPRequest.HWPRequest()' object."""

        if not self._hwpreq:
            from pepclibs.msr import HWPRequest # pylint: disable=import-outside-toplevel

            msr = self._get_msr()
            self._hwpreq = HWPRequest.HWPRequest(pman=self._pman, cpuinfo=self._cpuinfo, msr=msr)

        return self._hwpreq

    def _get_hwpreq_pkg(self):
        """Returns an 'HWPRequest.HWPRequest()' object."""

        if not self._hwpreq_pkg:
            from pepclibs.msr import HWPRequestPkg # pylint: disable=import-outside-toplevel

            msr = self._get_msr()
            self._hwpreq_pkg = HWPRequestPkg.HWPRequestPkg(pman=self._pman, cpuinfo=self._cpuinfo,
                                                           msr=msr)
        return self._hwpreq_pkg

    def _perf_to_freq(self, cpu, perf):
        """
        On many Intel platforms, the MSR registers such as 'MSR_HWP_REQUEST  use frequency ratio
        units - CPU frequency in Hz divided by 100MHz (bus clock). But on hybrid Intel platform
        (e.g., Alder Lake), the MSR works in  terms of platform-dependent abstract performance units
        on P-cores.

        Convert the performance units to CPU frequency in Hz.
        """

        bclk = self._get_bclk(cpu, not_supported_ok=True)
        if not bclk:
            return None

        if self._cpuinfo.info["hybrid"]:
            pcore_cpus = set(self._cpuinfo.get_hybrid_cpu_topology()["pcore"])
            # In HWP mode, the Linux 'intel_pstate' driver changes CPU frequency by programming
            # 'MSR_HWP_REQUEST'.
            # On many Intel platforms,the MSR is programmed in terms of frequency ratio (frequency
            # divided by 100MHz). But on hybrid Intel platform (e.g., Alder Lake), the MSR works in
            # terms of platform-dependent abstract performance units on P-cores. Convert the
            # performance units to CPU frequency in Hz.
            if cpu in pcore_cpus:
                freq = perf * self._perf_to_freq_factor
                # Round the frequency down to bus clock.
                # * Why rounding? CPU frequency changes in bus-clock increments.
                # * Why rounding down? Following how Linux 'intel_pstate' driver example.
                return freq - (freq % bclk)

        return perf * bclk

    def _get_freq_msr(self, key, cpu):
        """Read and return the minimum or maximum CPU frequency from 'MSR_HWP_REQUEST'."""

        # The corresponding 'MSR_HWP_REQUEST' feature name.
        feature_name = f"{key}_perf"

        try:
            hwpreq = self._get_hwpreq()
            if hwpreq.is_cpu_feature_pkg_controlled(feature_name, cpu):
                hwpreq = self._get_hwpreq_pkg()
        except ErrorNotSupported as err:
            _LOG.debug(err)
            return None

        try:
            perf = hwpreq.read_cpu_feature(feature_name, cpu)
        except ErrorNotSupported:
            _LOG.debug("CPU %d: HWP %s performance is not supported", cpu, key)
            return None

        return self._perf_to_freq(cpu, perf)

    def get_min_freq(self, cpu):
        """
        Get minimum CPU frequency via the 'MSR_HWP_REQUEST' model specific register. The arguments
        are as follows.
          * cpu - CPU number to get the frequency for.

        Return the minimum CPU frequency in Hz or 'None' if 'MSR_HWP_REQUEST' is not supported.
        """

        return self._get_freq_msr("min", cpu)

    def get_max_freq(self, cpu):
        """Same as 'get_min_freq()', but for the maximum CPU frequency."""

        return self._get_freq_msr("max", cpu)

    def _set_freq_msr(self, freq, key, cpu):
        """Set CPU frequency by writing to 'MSR_HWP_REQUEST'."""

        # The corresponding 'MSR_HWP_REQUEST' feature name.
        feature_name = f"{key}_perf"

        perf = None
        if self._cpuinfo.info["hybrid"]:
            pcore_cpus = set(self._cpuinfo.get_hybrid_cpu_topology()["pcore"])
            if cpu in pcore_cpus:
                perf = int((freq + self._perf_to_freq_factor - 1) / self._perf_to_freq_factor)

        if perf is None:
            bclk = self._get_bclk(cpu, not_supported_ok=False)
            perf = freq // bclk

        hwpreq = self._get_hwpreq()
        hwpreq.disable_cpu_feature_pkg_control(feature_name, cpu)
        hwpreq.write_cpu_feature(feature_name, perf, cpu)

    def set_min_freq(self, freq, cpu):
        """
        Set minimum CPU frequency via the 'MSR_HWP_REQUEST' model specific register. The arguments
        are as follows.
          * freq - the minimum frequency value to set, hertz.
          * cpu - CPU number to set the frequency for.
        """

        self._set_freq_msr(freq, "min", cpu)

    def set_max_freq(self, freq, cpu):
        """Same as 'set_min_freq()', but for the maximum CPU frequency."""

        self._set_freq_msr(freq, "max", cpu)

    def _get_platinfo(self):
        """Returns an 'PlatformInfo.PlatformInfo()' object."""

        if not self._platinfo:
            from pepclibs.msr import PlatformInfo # pylint: disable=import-outside-toplevel

            msr = self._get_msr()
            self._platinfo = PlatformInfo.PlatformInfo(pman=self._pman, cpuinfo=self._cpuinfo,
                                                       msr=msr)
        return self._platinfo

    def _get_trl(self):
        """Returns an 'TurboRatioLimit.TurboRatioLimit()' object."""

        if not self._trl:
            from pepclibs.msr import TurboRatioLimit # pylint: disable=import-outside-toplevel

            msr = self._get_msr()
            self._trl = TurboRatioLimit.TurboRatioLimit(pman=self._pman, cpuinfo=self._cpuinfo,
                                                        msr=msr)
        return self._trl

    def get_base_freq(self, cpu):
        """
        Get base CPU frequency from the 'MSR_PLATFORM_INFO' model-specific register. The arguments
        are as follows.
          * cpu - CPU number to get base frequency for.

        Return base CPU frequency in Hz or 'None' if 'MSR_PLATFORM_INFO' is not supported.
        """

        try:
            platinfo = self._get_platinfo()
            ratio = platinfo.read_cpu_feature("max_non_turbo_ratio", cpu)

            bclk = self._get_bclk(cpu)
            if bclk is not None:
                return ratio * bclk
        except ErrorNotSupported:
            return None

        return None

    def get_min_oper_freq(self, cpu):
        """
        Get the minimum CPU operating frequency from the 'MSR_PLATFORM_INFO' model-specific
        register. The arguments are as follows.
          * cpu - CPU number to get the minimum operating frequency for.

        Return the minium opeating CPU frequency in Hz or 'None' if 'MSR_PLATFORM_INFO' is not
        supported.
        """

        try:
            platinfo = self._get_platinfo()
            ratio = platinfo.read_cpu_feature("min_oper_ratio", cpu)

            bclk = self._get_bclk(cpu)
            if bclk is not None:
                return ratio * bclk
        except ErrorNotSupported:
            return None

        return None

    def get_max_eff_freq(self, cpu):
        """
        Get the maximum CPU efficiency frequency from the 'MSR_PLATFORM_INFO' model-specific
        register. The arguments are as follows.
          * cpu - CPU number to get the maximum efficiency frequency for.

        Return the maximum CPU efficiency frequency in Hz. Maximum efficiency frequency is the
        frequency with best CPU performance per watt ratio. Return  'None' if 'MSR_PLATFORM_INFO' is
        not supported.
        """

        try:
            platinfo = self._get_platinfo()
            ratio = platinfo.read_cpu_feature("max_eff_ratio", cpu)

            bclk = self._get_bclk(cpu)
            if bclk is not None:
                return ratio * bclk
        except ErrorNotSupported:
            return None

        return None

    def get_max_turbo_freq(self, cpu):
        """
        Get the maximum 1-core CPU turbo frequency from the 'MSR_TURBO_RATIO_LIMIT' model-specific
        register. The arguments are as follows.
          * cpu - CPU number to get the maximum turbo frequency for.

        Return the maximum CPU turbo frequency in Hz. Return 'None' if 'MSR_TURBO_RATIO_LIMIT' is
        not supported.
        """

        try:
            trl = self._get_trl()
        except ErrorNotSupported:
            return None

        try:
            ratio = trl.read_cpu_feature("max_1c_turbo_ratio", cpu)
        except ErrorNotSupported:
            try:
                # In this case 'MSR_TURBO_RATIO_LIMIT' encodes max. turbo ratio for groups of cores.
                # We can safely assume that group 0 will correspond to max. 1-core turbo, so we do
                # not need to look at 'MSR_TURBO_RATIO_LIMIT1'.
                ratio = trl.read_cpu_feature("max_g0_turbo_ratio", cpu)
            except ErrorNotSupported:
                _LOG.warn_once("CPU %d: module 'TurboRatioLimit' doesn't support "
                               "'MSR_TURBO_RATIO_LIMIT' for CPU '%s'%s\nPlease, contact project "
                               "maintainers.", cpu, self._cpuinfo.cpudescr, self._pman.hostmsg)
                return None

        try:
            bclk = self._get_bclk(cpu)
            if bclk is not None:
                return ratio * bclk
        except ErrorNotSupported:
            return None

        return None

    def __init__(self, pman=None, cpuinfo=None, msr=None, enable_cache=True):
        """
        The class constructor. The argument are as follows.
          * pman - the process manager object that defines the host to control CPU frequency on.
          * cpuinfo - CPU information object generated by 'CPUInfo.CPUInfo()'.
          * msr - an 'MSR.MSR()' object which should be used for accessing MSR registers.
          * enable_cache - this argument can be used to disable caching.
        """

        self._pman = pman
        self._cpuinfo = cpuinfo
        self._msr = msr
        self._enable_cache = enable_cache

        self._close_pman = pman is None
        self._close_cpuinfo = cpuinfo is None

        self._fsbfreq = None
        self._hwpreq = None
        self._hwpreq_pkg = None
        self._platinfo = None
        self._trl = None

        # Performance to frequency factor.
        self._perf_to_freq_factor = 78740157

        if not self._pman:
            self._pman = LocalProcessManager.LocalProcessManager()

        if not self._cpuinfo:
            self._cpuinfo = CPUInfo.CPUInfo(pman=self._pman)

    def close(self):
        """Uninitialize the class object."""

        close_attrs = ("_trl", "_platinfo", "_fsbfreq", "_hwpreq", "_hwpreq_pkg", "_cpuinfo",
                       "_pman")
        ClassHelpers.close(self, close_attrs=close_attrs)
