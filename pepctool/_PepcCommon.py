# -*- coding: utf-8 -*-
# vim: ts=4 sw=4 tw=100 et ai si
#
# Copyright (C) 2020-2021 Intel Corporation
# SPDX-License-Identifier: BSD-3-Clause
#
# Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>

"""
Misc. helpers shared between various 'pepc' commands.
"""

import logging
from pepclibs.helperlibs.Exceptions import Error, ErrorNotFound, ErrorNotSupported
from pepclibs.helperlibs import Systemctl, Trivial, ArgParse

_LOG = logging.getLogger()

def check_tuned_presence(pman):
    """Check if the 'tuned' service is active, and if it is, print a warning message."""

    try:
        with Systemctl.Systemctl(pman=pman) as systemctl:
            if systemctl.is_active("tuned"):
                _LOG.warning("the 'tuned' service is active%s! It may override the changes made by "
                             "'pepc'.\nConsider having 'tuned' disabled while experimenting with "
                             "power management settings.", pman.hostmsg)
    except ErrorNotFound:
        pass
    except Error as err:
        _LOG.warning("failed to check for 'tuned' presence:\n%s", err.indent(2))

def parse_cpus_string(string):
    """
    Parse string of comma-separated numbers and number ranges, and return them as a list of
    integers.
    """

    if string == "all":
        return string
    return ArgParse.parse_int_list(string, ints=True, dedup=True)

def get_cpus(args, cpuinfo, default_cpus="all", offline_ok=False):
    """
    Get list of CPUs based on requested CPU, core, die, and package numbers. The arguments are as
    follows.
      * args - the command line arguments object, includes attributes like 'cpus' and 'packages',
               which supposedly come from command line and which are parsed by this function in
               order to build a normalized list of CPU numbers.
      * cpuinfo - CPU information object generated by 'CPUInfo.CPUInfo()'.
      * default_cpus - used only when 'args' does not include any CPU, core, die, or package
                       numbers, supposedly because the user did not provide them via command-line
                       arguments. Specifies an integer list of CPU numbers to use in such case.
                       Value "all" means "all CPUs".
      * offline_ok - whether offline CPUs should be accepted or cause an exception.

    By default, offline CPUs are not allowed and will cause an exception. Use 'offline_ok=True' to
    allow for offline CPUs.

    If this functions ends up expanding special value "all" for 'args.cpus' or 'default_cpus', then:
      * if 'offline_ok' is 'False', only online CPUs are included, and no exception is raised for
        offline CPUs.
      * if 'offline_ok' is 'True', all online and offline CPUs will be included.

    But if this function ends up expanding special value "all" for 'args.cores', 'args.modules'
    'args.dies', or 'args.packages', then 'offline_ok' argument is not used (ignored). The reason
    for this is that Linux kernel does not provide topology information for offline CPUs. Only
    offline CPU numbers are known, but what package or core they belong to is unknown, and becomes
    known only when the CPU is onlined.
    """

    cpus = []

    if args.cpus:
        cpus += cpuinfo.normalize_cpus(cpus=parse_cpus_string(args.cpus), offline_ok=offline_ok)

    if args.cores:
        packages = parse_cpus_string(args.packages)
        if not packages:
            if cpuinfo.get_packages_count() != 1:
                raise Error("'--cores' must be used with '--packages'")
            packages = (0,)
        cpus += cpuinfo.cores_to_cpus(cores=parse_cpus_string(args.cores), packages=packages)

    if args.dies:
        packages = parse_cpus_string(args.packages)
        if not packages:
            if cpuinfo.get_packages_count() != 1:
                raise Error("'--dies' must be used with '--packages'")
            packages = (0,)
        cpus += cpuinfo.dies_to_cpus(dies=parse_cpus_string(args.dies), packages=packages)

    if args.packages and not (args.cores or args.dies):
        cpus += cpuinfo.packages_to_cpus(packages=parse_cpus_string(args.packages))

    # Note, module numbers are absolute.
    if args.modules:
        cpus += cpuinfo.modules_to_cpus(modules=parse_cpus_string(args.modules))

    if not cpus and default_cpus is not None:
        cpus = cpuinfo.normalize_cpus(parse_cpus_string(default_cpus), offline_ok=offline_ok)

    if args.core_siblings:
        return cpuinfo.select_core_siblings(cpus, parse_cpus_string(args.core_siblings))

    if args.module_siblings:
        return cpuinfo.select_module_siblings(cpus, parse_cpus_string(args.module_siblings))

    return Trivial.list_dedup(cpus)

def override_cpu_model(cpuinfo, model):
    """
    Override the CPU model. The arguments are as follows.
      * cpuinfo - CPU information object generated by 'CPUInfo.CPUInfo()'.
      * model - the target CPU model, can be integer or string representation of an decimal or hex.
    """

    model = str(model)
    try:
        cpuinfo.info["model"] = int(model)
    except (ValueError, TypeError):
        try:
            cpuinfo.info["model"] = int(model, 16)
        except (ValueError, TypeError):
            raise Error(f"bad CPU model '{model}': should be an integer") from None

    cpuinfo.cpudescr += f" overridden to {cpuinfo.info['model']:#x}"
    _LOG.warning(cpuinfo.cpudescr)

def expand_subprops(pnames, props):
    """
    Expand list of property names 'pnames' with sub-property names. The arguments are as follows.
      * pnames - a collection of property names to expand.
      * props - the properties dictionary (e.g., 'CStates.PROPS').

      This helper function takes a list of property names in 'pnames', and if any property in
      'pnames' has a sub-property, the sub-property names are inserted into 'pnames' right after the
      main property name. Well, the sub-property names are inserted to a copy of 'pnames', and the
      resulting copy is returned.
    """

    expanded = []

    for pname in pnames:
        expanded.append(pname)

        spnames = []
        prop = props.get(pname)
        if prop:
            spnames = prop.get("subprops", [])

        for spname in spnames:
            expanded.append(spname)

    return expanded

def parse_mechanisms(mechanisms, pobj):
    """
    Parse and validate a string of comma-separated mechanism names. Return the resulting mechanism
    names list.
    """

    mnames = Trivial.split_csv_line(mechanisms, dedup=True)
    for mname in mnames:
        if mname not in pobj.mechanisms:
            mnames = ", ".join(pobj.mechanisms)
            raise ErrorNotSupported(f"mechanism '{mname}' is not supported. The supported " \
                                    f"mechanisms are: {mnames}")
    return mnames
